'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var LastAction;
(function (LastAction) {
    LastAction["NONE"] = "none";
    LastAction["ENTER"] = "enter";
    LastAction["LEAVE"] = "leave";
})(LastAction || (LastAction = {}));

class SceneContext {
    constructor(options) {
        /**
         * Is the scene canceled, used in leaveHandler()
         *
         * @example
         * ctx.scene.leave({
         *   canceled: true
         * });
         */
        this.canceled = false;
        this.lastAction = LastAction.NONE;
        /**
         * Controlled behavior leave
         */
        this.leaved = false;
        this.context = options.context;
        this.repository = options.repository;
        this.updateSession();
    }
    /**
     * Returns current scene
     */
    get current() {
        return this.repository.get(this.session.current);
    }
    /**
     * Enter to scene
     *
     * @example
     * ctx.scene.enter('signup');
     * ctx.scene.enter('signup', {
     *   silent: true,
     *   state: {
     *     username: 'Super_Developer'
     *   }
     * });
     */
    async enter(slug, options = {}) {
        const scene = this.repository.strictGet(slug);
        const { current } = this;
        const isNotCurrent = current !== null && current.slug !== scene.slug;
        if (!this.leaved && isNotCurrent) {
            await this.leave({
                silent: options.silent
            });
        }
        if (this.leaved && isNotCurrent) {
            this.leaved = false;
            this.reset();
        }
        this.lastAction = LastAction.ENTER;
        this.session.current = scene.slug;
        Object.assign(this.state, options.state || {});
        if (options.silent) {
            return;
        }
        await scene.enterHandler(this.context);
    }
    /**
     * Reenter to current scene
     *
     * @example
     * ctx.scene.reenter();
     */
    async reenter() {
        const { current } = this;
        if (!current) {
            throw new Error('There is no active scene to enter');
        }
        await this.enter(current.slug);
    }
    /**
     * Leave from current scene
     *
     * @example
     * ctx.scene.leave();
     * ctx.scene.leave({
     *   silent: true,
     *   canceled: true
     * });
     */
    async leave(options = {}) {
        const { current } = this;
        if (!current) {
            return;
        }
        this.leaved = true;
        this.lastAction = LastAction.LEAVE;
        if (!options.silent) {
            this.canceled = options.canceled !== undefined
                ? options.canceled
                : false;
            await current.leaveHandler(this.context);
        }
        if (this.leaved) {
            this.reset();
        }
        this.leaved = false;
        this.canceled = false;
    }
    /**
     * Reset state/session
     */
    reset() {
        // eslint-disable-next-line no-underscore-dangle
        delete this.context.session.__scene;
        this.updateSession();
    }
    /**
     * Updates session and state is lazy
     */
    updateSession() {
        // eslint-disable-next-line no-underscore-dangle
        this.session = new Proxy(this.context.session.__scene || {}, {
            set: (target, prop, value) => {
                target[prop] = value;
                // eslint-disable-next-line no-underscore-dangle
                this.context.session.__scene = target;
                return true;
            }
        });
        this.state = new Proxy(this.session.state || {}, {
            set: (target, prop, value) => {
                target[prop] = value;
                this.session.state = target;
                return true;
            }
        });
    }
}

class StepSceneContext {
    constructor(options) {
        this.stepChanged = false;
        this.context = options.context;
        this.steps = options.steps;
    }
    /**
     * The first enter to the handler
     */
    get firstTime() {
        const { firstTime = true } = this.context.scene.session;
        return firstTime;
    }
    /**
     * Returns current stepId
     */
    get stepId() {
        return this.context.scene.session.stepId || 0;
    }
    /**
     * Sets current stepId
     */
    set stepId(stepId) {
        const { session } = this.context.scene;
        session.stepId = stepId;
        session.firstTime = true;
        this.stepChanged = true;
    }
    /**
     * Returns current handler
     */
    get current() {
        return this.steps[this.stepId] || null;
    }
    /**
     * Reenter current step handler
     *
     * @example
     * ctx.scene.step.reenter();
     */
    async reenter() {
        const { current } = this;
        if (!current) {
            await this.context.scene.leave();
            return;
        }
        this.stepChanged = false;
        await current(this.context);
        if (this.context.scene.lastAction !== LastAction.LEAVE && !this.stepChanged) {
            this.context.scene.session.firstTime = false;
        }
    }
    /**
     * Move to the next handler
     *
     * @example
     * ctx.scene.step.next();
     * ctx.scene.step.next({
     *   silent: true
     * });
     */
    async next({ silent = false } = {}) {
        this.stepId += 1;
        if (silent) {
            return;
        }
        await this.reenter();
    }
    /**
     * Move to the previous handler
     *
     * @example
     * ctx.scene.step.previous();
     * ctx.scene.step.previous({
     *   silent: true
     * });
     */
    async previous({ silent = false } = {}) {
        this.stepId -= 1;
        if (silent) {
            return;
        }
        await this.reenter();
    }
}

/* eslint-disable import/no-cycle */

class CacheRepository {
    constructor({ sortingValues } = {}) {
        this.collection = new Map();
        this.keys = [];
        this.values = [];
        this.sortingValues = sortingValues;
    }
    /**
     * Checks has value by key
     */
    has(key) {
        return this.collection.has(key);
    }
    /**
     * Sets value by key
     */
    set(key, value) {
        this.collection.set(key, value);
        this.keys = [...this.collection.keys()];
        this.values = [...this.collection.values()];
        if (this.sortingValues) {
            this.values.sort(this.sortingValues);
        }
    }
    /**
     * Returns value by key
     */
    get(key) {
        return this.collection.get(key) || null;
    }
    /**
     * Sets value by key else error if exits
     */
    strictSet(key, value) {
        if (this.collection.has(key)) {
            throw new Error(`Value by ${key} already exists`);
        }
        return this.set(key, value);
    }
    /**
     * Returns value by key else error
     */
    strictGet(key) {
        const value = this.get(key);
        if (!value) {
            throw new Error(`Value by ${key} not found`);
        }
        return value;
    }
    /**
     * Returns iterator
     */
    [Symbol.iterator]() {
        return this.collection[Symbol.iterator]();
    }
}

class SceneManager {
    constructor(rawOptions = {}) {
        this.repository = new CacheRepository();
        const options = Array.isArray(rawOptions)
            ? {
                scenes: rawOptions
            }
            : rawOptions;
        if (options.scenes) {
            for (const scene of options.scenes) {
                this.addScene(scene);
            }
        }
    }
    /**
     * Adds a scene to the shared list
     */
    addScene(scene) {
        this.repository.set(scene.slug, scene);
        return this;
    }
    /**
     * Returns the middleware for embedding
     */
    get middleware() {
        return (context, next) => {
            context.scene = new SceneContext({
                context,
                repository: this.repository
            });
            return next();
        };
    }
    /**
     * Returns the middleware for intercept
     */
    get middlewareIntercept() {
        return (context, next) => {
            if (!context.scene.current) {
                return next();
            }
            return context.scene.reenter();
        };
    }
}

class StepScene {
    constructor(slug, rawOptions) {
        const options = Array.isArray(rawOptions)
            ? {
                steps: rawOptions
            }
            : rawOptions;
        this.slug = slug;
        this.steps = options.steps;
        this.onEnterHandler = options.enterHandler || (() => { });
        this.onLeaveHandler = options.leaveHandler || (() => { });
    }
    async enterHandler(context) {
        context.scene.step = new StepSceneContext({
            context,
            steps: this.steps
        });
        // @ts-ignore
        await this.onEnterHandler(context);
        if (context.scene.lastAction !== LastAction.LEAVE) {
            await context.scene.step.reenter();
        }
    }
    leaveHandler(context) {
        // @ts-ignore
        return this.onLeaveHandler(context);
    }
}

exports.SceneContext = SceneContext;
exports.SceneManager = SceneManager;
exports.StepScene = StepScene;
exports.StepSceneContext = StepSceneContext;
exports.default = SceneManager;
