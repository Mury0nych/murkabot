class MemoryStorage {
    constructor() {
        this.store = new Map();
    }
    async has(key) {
        return this.store.has(key);
    }
    async get(key) {
        return this.store.get(key) || null;
    }
    async set(key, value) {
        this.store.set(key, value);
        return true;
    }
    async delete(key) {
        return this.store.delete(key);
    }
}

class SessionManager {
    constructor(options = {}) {
        this.storage = options.storage || (new MemoryStorage());
        this.contextKey = options.contextKey || 'session';
        this.getStorageKey = options.getStorageKey || (context => (String(context.senderId)));
    }
    /**
     * Returns the middleware for embedding
     */
    get middleware() {
        const { storage, contextKey, getStorageKey } = this;
        return async (context, next) => {
            const storageKey = getStorageKey(context);
            let changed = false;
            const wrapSession = (targetRaw) => (
            // eslint-disable-next-line no-use-before-define
            new Proxy({ ...targetRaw, $forceUpdate }, {
                set: (target, prop, value) => {
                    changed = true;
                    target[prop] = value;
                    return true;
                },
                deleteProperty(target, prop) {
                    changed = true;
                    delete target[prop];
                    return true;
                }
            }));
            const $forceUpdate = () => {
                // eslint-disable-next-line no-use-before-define
                if (Object.keys(session).length > 1) {
                    changed = false;
                    // eslint-disable-next-line no-use-before-define
                    return storage.set(storageKey, session);
                }
                return storage.delete(storageKey);
            };
            const initialSession = await storage.get(storageKey) || {};
            let session = wrapSession(initialSession);
            Object.defineProperty(context, contextKey, {
                get: () => session,
                set: (newSession) => {
                    session = wrapSession(newSession);
                    changed = true;
                }
            });
            await next();
            if (!changed) {
                return;
            }
            await $forceUpdate();
        };
    }
}

export default SessionManager;
export { MemoryStorage, SessionManager };
